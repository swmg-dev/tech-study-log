날짜별 README.md

# 📅 [2025-10-08~31] 학습 기록

## 🔥 학습 내용

1. 함수 (69-76강) [2025-10-08]
   함수: 어떠한 목적을 가지고 작성된 코드들을 묶어놓은 하나의 코드 실행 단위

함수는 데이터를 전달해줄 수있다.
-> 함수를 호출할때 사용하는 소괄호 안에 넘겨줄 데이터를 적으면 된다.

함수를 호출할 때 전달한 데이터 값은 함수 선언 부분에서 받아서 사용해야 함
-> 전달해 준 개수만큼 콤마로 구분해서 함수 선언 부분의 소괄호 안에 변수를 작성한다.
-> 전달한 순서대로 함수 선언부에서 그대로 전달받게 된다

인수: 넘겨주는 데이터(콤마로 구분하여 여러 개 전달 가능)
매개변수: 인수를 받기 위해서 함수 선언부에 적은 변수
-> 선언된 함수 내부에서 자유롭게 사용가능

함수 표현식: 함수 자체를 변수에 저장하는 개념이다.
즉, function 키워드 다음에 붙은 이름은 외부에서 쓸 수 없고,
실제로 호출할때는 그 함수를 담고 있는 변수 이름을 써야 한다.

가변인자함수: 매개변수가 변할 수 있는 함수

arguments 객체는 함수 내부에 존재하고 배열로서의 특징, 객체 특징도 가지고 있는 특별한 객체

스프레드연산자(...)

- 어떠한 매개변수에 스프레드 연산자를 붙여주게 되면 전달한 인수가 몇개든지 상관하지 않고 이 인수가 배열로 할당하게 된다
- 스프레드 연산자가 붙은 변수의 이름을 함수 내부에서 활용
- 매개변수를 원하는 만큼 지정도 가능 => 지정하고 지정되지 않은 나머지 것들은 스프레드 연산자 매개변수에 할당이 된다(나머지 매개변수)
- 항상 나머지 매개변수는 함수 매개변수 선언 부분 마지막에 오거나 단독으로 사용해야 한다

return

- 함수 내부에서 함수 외부로 어떠한 데이터를 전달(반환)하기 위해서 사용하는 키워드

* return 문이 실행되는 즉시 그 함수는 종료가 된다

객체리터럴: 키와 값으로 구성된 속성들로 이루어진 데이터 형태

- 키의 값이 함수인 속성을 method(메소드)로 부름
  { key: value, key2 : value2, ...}

객체 안에있는 속성의 값을 참조하려면 this를 사용한다

this
메소드 안에서 자기 자신이 속해 있는 객체를 가리킨다

객체 리터럴에서 사용되는 메소드 안에서는 this라는 키워드 사용

화살표 함수: 기존 선언했던 함수 표현식 방식에서 좀 더 간단해진 방법
차이점
a. 만약 매개변수가 1개일 경우 소괄호 생략 가능
b. 중괄호안에있는 코드가 한줄이라면 중괄호랑 return 키워드 생략 가능
c. arguments 객체 없다. 단, 스프레드 연산자를 사용한 가변인자 함수는 사용 가능하다
d. 화살표 함수 안에는 this 키워드 없다

2. 스코프 (77-83강) [2025-10-08]
   스코프(scope): 변수가 가지는 유효범위 (전역 스코프/지역스코프)
   변수를 어느 부분에 선언하느냐에 따라서 그 변수가 가지게 되는 유효 범위가 달라짐

   함수 외부 영역은 전역 스코프 영역,
   -> 전역 스코프 영역에서 선언된 변수는 전역 변수(모든 영역에서 변수 참조 가능)
   -> 전역 스코프 영역은 오직 1개만 존재
   함수 내부 영역은 지역 스코프 영역이 된다
   -> 지역 스코프 영역에서 선언된 변수는 지역 변수(같은 지역 스코프에서만 변수 참조 가능
   -> 함수 여러개 선언하면 여러 개 생길 수 있다)

어떠한 변수를 참조하려고 할 때 기본적으로 같은 스코프안에 있는 것들을 우선시해서 참조하고, 만약 같은 스코프에서 참조할 만한 것들이 없다라고 한다면 전역 스코프를 확인한다.
만약 전역 스코프에서도 없으면 undefined로 반환해서 그 값이 출력되게 한다

지역 스코프에서만 전역 스코프를 참조할 수 있고,
전역 스코프에서는 지역 스코프를 참조할 수 없다

지역 스코프에서 다른 지역 스코프의 변수를 참조할 수 없다

같은 스코프 안에서 let, const 중복될 수 없다 -> 스코프 범위 중요!

- 함수 레벨 스코프: 함수를 기준으로 스코프의 영역이 나뉘는 것을 의미
- 블록 레벨 스코프: 중괄호({})로 스코프가 전역 스코프와 지역 스코프로 나뉘는 것을 의미
  -> 오로지 let, const 키워드로 선언된 변수만 블록 레벨 스코프의 영향을 받는다

암묵적 전역 변수: var, let, const 키워드를 생략하고 변수를 선언하면 암묵적으로 전역 스코프에 var 키워드를 사용해서 전역 변수를 선언함
-> 어떠한 문법이든 변수를 선언하거나 초기화하는 부분에서는 let, const 키워드를 사용해라

3. 실행 컨텍스트와 클로저 (84-94강) [2025-10-09]

- 스택(stack): 한 쪽 긑에서만 자료를 넣고 뺄 수 있는 LIFO형식 자료 구조
- LIFO: Last In First Out 나중에 들어간 데이터가 가장 먼저 나온다

- 실행 컨텍스트: ECMAScript에서는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념(js 코드를 실행하기 위해서 js 엔진이 생성하는 공간)

크게보면 Javascipt는 전역 실행 컨텍스트와 여러개의 함수 실행 컨텍스트만 존재
모든 실행 컨텍스트의 내부에는 렉시컬 환경 공간 포함하고 있음

- 렉시컬 환경(환경 레코드, 외부 렉시컬 환경으로 구성)

* 환경 레코드: 코드 실행에 필요한 여러가지 정보 저장
* 외부 렉시컬 환경: 자신을 생성한 외부 렉시컬 환경 참조 정보

- 스코프 체인: 스코프가 나중에 생성된 실행 컨텍스트에 의해서 먼저 생성된 실행 컨텍스트를 바라보는 형태로 연결되어져 있는 현상

> 지금까지 내용 일단 정리: 코드를 작성하면 크게 전역 실행 컨텍스트와 함수 실행 컨텍스트가 존재해. 코드 내용에 따라 다를수있어. 그리고 실행 컨텍스트 내부에는 렉시컬 환경 공간을 포함해. 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경으로구성되는데 환경 레코드에는 코드 실행에 필요한 정보들이 저장되고 외부 렉시컬 환경이 중요해 전역 실행 컨텍스트에서는 제일 최상위이기 때문에 참조할게 없어서 전역 실행 컨텍스트 외부렉시컬 환경에는 참조할 정보가 들어있지 않아. 그이후의 함수 실행 컨텍스트는 있지. 그전의 걸 참조하는 방향을 가리키고 이걸 스코프 체인이라고 해. 예를 들어 전역, outer, inner 함수들이 잇다면 Inner함수에서a를 호출한다고 한다면 a라는 정보는 외부 렉시컬 환경이 참조하는 outer 를 확인하고 a정보가 있다면 그걸로 출력하고 없다면 outer가 참조하는 전역에서 a의 정보를 확인해 있다면 출력하고 없다면 a가 defined라고 나오게 되는 거지

- 클로저: 실행 컨텍스트가 온전히 삭제되지 못하고 메모리상 어떤 공간에 해당 실행 컨텍스트의 렉시컬 환경을 기억하고 있는 일련의 과정들
  장점: 현재 상태를 기억하고 변경된 최신 상태를 유지

클로저가 구현된 코드를 작성하게 된다면 클로저가 참조하고 있는 그 임시적인 메모리 공간을 완전히 삭제해주기 위해서 null값을 할당해 준다 -> 메모리 낭비 해결

- 호이스팅: 자바스크립트가 실행되기 전에, 자바스크립트 코드를 선언과 할당으로 분리한 후 (선언 부분을) 자신의 스코프 영역의 최상단으로 끌어올리는 현상
  -> 함수 선언문과 함수 표현식은 차이가 있다
  -> var 키워드에서만 호이스팅 발생(let, const는 안된다)
  -> 일시적 사각지대: let, const 키워드가 호이스팅 되지 않은 현상

- 즉시 실행 함수: 함수를 선언함과 동시에 호출도 하는 함수 형태
  -> 선언문 형태, 익명 함수 형태, 화살표 함수로 사용해도 실행 가능
  -> 매개변수가 있는 경우는 똑같이 전달해주면 된다
  -> 즉시 실행 함수가 변수에 할당되어야 하는 경우에는 함수 선언부분을 소괄호로 감싸지 않아도 된다(단, 화살표 함수가 아닐 때만 가능)
  (함수)();

즉시실행함수는 왜 사용하는 걸까?
가장 큰 이유는 한번만 실행되면 되는 함수를 선언해야 하는 경우이다.
-> 한번만 호출해야 하는 함수라면 그 웹브라우저의 종료가 끝날때까지 자바스크립트의 메모리에 떠 있는 전역 스코프에 선언되는 방식보다는 즉시실행함수를 사용하면 메모리 낭비도 줄어들고 상황에 따라 효율적인 코드가 된다 4. 동기와 비동기 (95-103강)

---

5. 객체 (104-117강)

6. 표준 내장 객체 (118-140강)

7. Browser Object Model (141-152강)

8. DOM 기본 (153-159강)

9. DOM 노드 선택 (160-166강)

10. DOM 조작 (167-190강)

11. 이벤트 (191-218강)

12. 폼 제어 (219-230)
