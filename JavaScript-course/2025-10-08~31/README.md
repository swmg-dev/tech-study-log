날짜별 README.md

# 📅 [2025-10-08~31] 학습 기록

## 🔥 학습 내용

1. 함수 (69-76강) [2025-10-08]
   함수: 어떠한 목적을 가지고 작성된 코드들을 묶어놓은 하나의 코드 실행 단위

함수는 데이터를 전달해줄 수있다.
-> 함수를 호출할때 사용하는 소괄호 안에 넘겨줄 데이터를 적으면 된다.

함수를 호출할 때 전달한 데이터 값은 함수 선언 부분에서 받아서 사용해야 함
-> 전달해 준 개수만큼 콤마로 구분해서 함수 선언 부분의 소괄호 안에 변수를 작성한다.
-> 전달한 순서대로 함수 선언부에서 그대로 전달받게 된다

인수: 넘겨주는 데이터(콤마로 구분하여 여러 개 전달 가능)
매개변수: 인수를 받기 위해서 함수 선언부에 적은 변수
-> 선언된 함수 내부에서 자유롭게 사용가능

함수 표현식: 함수 자체를 변수에 저장하는 개념이다.
즉, function 키워드 다음에 붙은 이름은 외부에서 쓸 수 없고,
실제로 호출할때는 그 함수를 담고 있는 변수 이름을 써야 한다.

가변인자함수: 매개변수가 변할 수 있는 함수

arguments 객체는 함수 내부에 존재하고 배열로서의 특징, 객체 특징도 가지고 있는 특별한 객체

스프레드연산자(...)

- 어떠한 매개변수에 스프레드 연산자를 붙여주게 되면 전달한 인수가 몇개든지 상관하지 않고 이 인수가 배열로 할당하게 된다
- 스프레드 연산자가 붙은 변수의 이름을 함수 내부에서 활용
- 매개변수를 원하는 만큼 지정도 가능 => 지정하고 지정되지 않은 나머지 것들은 스프레드 연산자 매개변수에 할당이 된다(나머지 매개변수)
- 항상 나머지 매개변수는 함수 매개변수 선언 부분 마지막에 오거나 단독으로 사용해야 한다

return

- 함수 내부에서 함수 외부로 어떠한 데이터를 전달(반환)하기 위해서 사용하는 키워드

* return 문이 실행되는 즉시 그 함수는 종료가 된다

객체리터럴: 키와 값으로 구성된 속성들로 이루어진 데이터 형태

- 키의 값이 함수인 속성을 method(메소드)로 부름
  { key: value, key2 : value2, ...}

객체 안에있는 속성의 값을 참조하려면 this를 사용한다

this
메소드 안에서 자기 자신이 속해 있는 객체를 가리킨다

객체 리터럴에서 사용되는 메소드 안에서는 this라는 키워드 사용

화살표 함수: 기존 선언했던 함수 표현식 방식에서 좀 더 간단해진 방법
차이점
a. 만약 매개변수가 1개일 경우 소괄호 생략 가능
b. 중괄호안에있는 코드가 한줄이라면 중괄호랑 return 키워드 생략 가능
c. arguments 객체 없다. 단, 스프레드 연산자를 사용한 가변인자 함수는 사용 가능하다
d. 화살표 함수 안에는 this 키워드 없다

2. 스코프 (77-83강) [2025-10-08]
   스코프(scope): 변수가 가지는 유효범위 (전역 스코프/지역스코프)
   변수를 어느 부분에 선언하느냐에 따라서 그 변수가 가지게 되는 유효 범위가 달라짐

   함수 외부 영역은 전역 스코프 영역,
   -> 전역 스코프 영역에서 선언된 변수는 전역 변수(모든 영역에서 변수 참조 가능)
   -> 전역 스코프 영역은 오직 1개만 존재
   함수 내부 영역은 지역 스코프 영역이 된다
   -> 지역 스코프 영역에서 선언된 변수는 지역 변수(같은 지역 스코프에서만 변수 참조 가능
   -> 함수 여러개 선언하면 여러 개 생길 수 있다)

어떠한 변수를 참조하려고 할 때 기본적으로 같은 스코프안에 있는 것들을 우선시해서 참조하고, 만약 같은 스코프에서 참조할 만한 것들이 없다라고 한다면 전역 스코프를 확인한다.
만약 전역 스코프에서도 없으면 undefined로 반환해서 그 값이 출력되게 한다

지역 스코프에서만 전역 스코프를 참조할 수 있고,
전역 스코프에서는 지역 스코프를 참조할 수 없다

지역 스코프에서 다른 지역 스코프의 변수를 참조할 수 없다

같은 스코프 안에서 let, const 중복될 수 없다 -> 스코프 범위 중요!

- 함수 레벨 스코프: 함수를 기준으로 스코프의 영역이 나뉘는 것을 의미
- 블록 레벨 스코프: 중괄호({})로 스코프가 전역 스코프와 지역 스코프로 나뉘는 것을 의미
  -> 오로지 let, const 키워드로 선언된 변수만 블록 레벨 스코프의 영향을 받는다

암묵적 전역 변수: var, let, const 키워드를 생략하고 변수를 선언하면 암묵적으로 전역 스코프에 var 키워드를 사용해서 전역 변수를 선언함
-> 어떠한 문법이든 변수를 선언하거나 초기화하는 부분에서는 let, const 키워드를 사용해라

3. 실행 컨텍스트와 클로저 (84-94강) [2025-10-09]

- 스택(stack): 한 쪽 긑에서만 자료를 넣고 뺄 수 있는 LIFO형식 자료 구조
- LIFO: Last In First Out 나중에 들어간 데이터가 가장 먼저 나온다

- 실행 컨텍스트: ECMAScript에서는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념(js 코드를 실행하기 위해서 js 엔진이 생성하는 공간)

크게보면 Javascipt는 전역 실행 컨텍스트와 여러개의 함수 실행 컨텍스트만 존재
모든 실행 컨텍스트의 내부에는 렉시컬 환경 공간 포함하고 있음

- 렉시컬 환경(환경 레코드, 외부 렉시컬 환경으로 구성)

* 환경 레코드: 코드 실행에 필요한 여러가지 정보 저장
* 외부 렉시컬 환경: 자신을 생성한 외부 렉시컬 환경 참조 정보

- 스코프 체인: 스코프가 나중에 생성된 실행 컨텍스트에 의해서 먼저 생성된 실행 컨텍스트를 바라보는 형태로 연결되어져 있는 현상

> 지금까지 내용 일단 정리: 코드를 작성하면 크게 전역 실행 컨텍스트와 함수 실행 컨텍스트가 존재해. 코드 내용에 따라 다를수있어. 그리고 실행 컨텍스트 내부에는 렉시컬 환경 공간을 포함해. 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경으로구성되는데 환경 레코드에는 코드 실행에 필요한 정보들이 저장되고 외부 렉시컬 환경이 중요해 전역 실행 컨텍스트에서는 제일 최상위이기 때문에 참조할게 없어서 전역 실행 컨텍스트 외부렉시컬 환경에는 참조할 정보가 들어있지 않아. 그이후의 함수 실행 컨텍스트는 있지. 그전의 걸 참조하는 방향을 가리키고 이걸 스코프 체인이라고 해. 예를 들어 전역, outer, inner 함수들이 잇다면 Inner함수에서a를 호출한다고 한다면 a라는 정보는 외부 렉시컬 환경이 참조하는 outer 를 확인하고 a정보가 있다면 그걸로 출력하고 없다면 outer가 참조하는 전역에서 a의 정보를 확인해 있다면 출력하고 없다면 a가 defined라고 나오게 되는 거지

- 클로저: 실행 컨텍스트가 온전히 삭제되지 못하고 메모리상 어떤 공간에 해당 실행 컨텍스트의 렉시컬 환경을 기억하고 있는 일련의 과정들
  장점: 현재 상태를 기억하고 변경된 최신 상태를 유지

클로저가 구현된 코드를 작성하게 된다면 클로저가 참조하고 있는 그 임시적인 메모리 공간을 완전히 삭제해주기 위해서 null값을 할당해 준다 -> 메모리 낭비 해결

- 호이스팅: 자바스크립트가 실행되기 전에, 자바스크립트 코드를 선언과 할당으로 분리한 후 (선언 부분을) 자신의 스코프 영역의 최상단으로 끌어올리는 현상
  -> 함수 선언문과 함수 표현식은 차이가 있다
  -> var 키워드에서만 호이스팅 발생(let, const는 안된다)
  -> 일시적 사각지대: let, const 키워드가 호이스팅 되지 않은 현상

- 즉시 실행 함수: 함수를 선언함과 동시에 호출도 하는 함수 형태
  -> 선언문 형태, 익명 함수 형태, 화살표 함수로 사용해도 실행 가능
  -> 매개변수가 있는 경우는 똑같이 전달해주면 된다
  -> 즉시 실행 함수가 변수에 할당되어야 하는 경우에는 함수 선언부분을 소괄호로 감싸지 않아도 된다(단, 화살표 함수가 아닐 때만 가능)
  (함수)();

즉시실행함수는 왜 사용하는 걸까?
가장 큰 이유는 한번만 실행되면 되는 함수를 선언해야 하는 경우이다.
-> 한번만 호출해야 하는 함수라면 그 웹브라우저의 종료가 끝날때까지 자바스크립트의 메모리에 떠 있는 전역 스코프에 선언되는 방식보다는 즉시실행함수를 사용하면 메모리 낭비도 줄어들고 상황에 따라 효율적인
코드가 된다

4. 동기와 비동기 (95-103강) [2025-10-09]

- 단일 스레드: 실행 컨텍스트를 관리하는 스택 구조는 자바스크립트에서 한 개만 존재
  => 자바스크립트는 스택 구조가 동시 다발적으로 여러 개 생성되어서 동시에 어떤 작업이 처리되는 멀티 스레드 방식이 아닌 하나의 스택 구조 안에서 실행컨텍스트들이 생성되고 삭제되면서 코드가 처리되는 단일 스레드 방식이다.

자바스크립트는 동기식으로 코드가 실행된다. 동기식 언어이다라고 표현
=> 코드를 순차적으로 실행한다(다른 코드의 응답이 끝날때까지 기다렸다가 그 다음 코드를 실행하는 것을 의미)

동기식 방식의 언어 장점: 코드의 순서가 보장된다(내가 원하는 코드 처리를 순차적으로 할 수있게끔 보장해 준다)
-> 중간에 코드가 오래 걸린다면 기다리게 되고, 전체적으로 늦게 되는 현상 발생

- 비동기: 코드의 실행을 기다리지 않고 다음 코드를 즉시 실행시키게 하는 것
  비동기식을 지원하는 대표 함수

* setTimeout 함수: 첫 번째 매개변수로 전달된 함수 안에 있는 코드를 두 번째 매개변수로 전달된 밀리세컨드 시간 뒤에 실행시키는 대표적인 비동기 함수이다
  - 자바스크립트에 내장되어 있는 함수이기 때문에 별도의 선언없이 어느 위치에서든 즉시 사용 가능
  - 1000ms는 1초
* 비동기 사용시 얼마나 걸리든 신경 쓰지 않고 처리가 완료되면 나중에 알아서 실행되게끔 코드가 개선이 된다-> 프로그램 성능 향상

코드 작성하다보면 비동기로 처리되어야 함에도 코드의 실행 순서가 보장되어야 하는 경우가 있다.
-> 비동기를 유지하면서 코드의 순서를 보장할 수 있는 방법들이 있다.

방법 1) callback 함수
다른 함수의 매개변수로써 사용되는 함수이다.
-> 매개변수로 함수를 전달할 때는 호출하는 식이 아닌 함수의 이름을 전달해서 참조가 가능하게 사용해야 함
-> 기다리지 않고 비동기처럼 실행을 시키게 하면서 순서까지 보장한다
-> 콜백지옥 해결할 방법이 필요(가독성이 좋지 않음

방법 2) promise(생성자 함수)

- 대기 상태: promise 문법이 실행되지 않는 이러한 상태
  promise 문법 내부에 있는 자바스크립트 코드의 실행이 전부 다 끝나면 내부적으로 전달된 resolve 함수를 호출한다.
  resolve는 함수 형태로 호출하는 거라서 매개변수를 전달해 줄 수도 있다

- 이행 상태: 호출되면 promise 문법은 내부적으로 이행 상태가 되었다.
  -> 이행 상태가 되면 promise 문법에서 약속되어진 then함수 추가적으로 사용 가능
  -> then 함수는 내부적으로 callback 함수를 하나 전달받고 이 전달받은 callback 함수에서 어떠한 결과 값을 처리할 수 있게 된다
  -> 이행상태는 여러개의 then을 연속적으로 연결해서 사용할 수 있다
  -> then함수에서 반환을 해주게 되면 then 함수를 한 번 더 사용해서 그 결과 값을 다시 한 번 받을 수 있게 된다.

  - promise chaining: den 함수를 연속적으로 이용해서 처리하는 것

- 거절 상태:promise 문법 내부에 적혀져 있던 코드를 실행하다가 실패하는 상황이 발생하면 reject 함수를 호출해야 한다
  -> reject도 함수를 호출하기 때문에 매개변수를 전달할 수 있다.
  -> 단순히 문자열을 매개변수로 넘겨주는게 아니라 newError 에러 객체를 호출하여 전달한다(객체이자 생성자 함수)
  -> 함수가 호출되면 promise 문법은 내부적으로 거절 상태가 되었다고 표현함
  거절 상태가 되면 미리 약속되어져있는 catch함수 사용 가능
  -> catch 함수도 내부적으로 callback 함수를 전달 받는다.
  -> 무언가 실패했을때의 처리를 catch라는 약속된 함수 내부에서 처리 할 수있다는 얘기다

- new 키워드: 생성자 함수를 호출할 때 사용하는 키워드

방법 3) async, await

- async 키워드는 promise resolve를 한 것과 똑같은 처리를 해주게 하는 키워드이다
  -> async 사용하고 return 문 사용하면 resolve한 것과 똑같은 코드 만들 수 있다.
  -> promise를 좀 더 쉽게 만들어 줄 수 있는 새로운 키워드

* await 키워드는 promise resolve 처리되는 코드의 실행을 기다려 준다
  -> 단, async 키워드 내부에서만 사용 가능
  -> promise 지옥 문제 해결

async, await 키워드가 붙은 문법에서 에러 처리 방법 ->try catch
에러를 핸들링한다~

5. 객체 (104-117강)

6. 표준 내장 객체 (118-140강)

7. Browser Object Model (141-152강)

8. DOM 기본 (153-159강)

9. DOM 노드 선택 (160-166강)

10. DOM 조작 (167-190강)

11. 이벤트 (191-218강)

12. 폼 제어 (219-230)
